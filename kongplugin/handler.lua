---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/3/9 15:58
---
-- 扩展基本插件处理程序是可选的，因为Lua中没有真正的接口概念，
-- 但是基本插件处理程序的方法可以从子实现中调用，
-- 并将在“error.log”中打印日志(其中打印所有日志)。
local BasePlugin = require "kong.plugins.base_plugin"
local ResponseHandler = BasePlugin:extend()
local url = require "socket.url"
local http = require "resty.http"
local kong = kong
local data = kong.ctx.plugin

ResponseHandler.PRIORITY = "1000"
ResponseHandler.VERSION = "0.1.0"
-- 你的插件处理程序的构造函数。
-- 如果要扩展基本插件处理程序，它的唯一作用就是用名称实例化自己。
-- 该名称是您的插件名称，因为它将打印在日志中
function ResponseHandler:new()
    ResponseHandler.super.new(self, "request-management-plugin")
end

--实现请求分发
function ResponseHandler:access(config)
    -- Eventually, execute the parent implementation
    -- (will log that your plugin is entering this context)
    ResponseHandler.super.access(self)
    local bodyarray = {}
    local overlaidbody = {}
    local json_responsebody
    local requestmap
    if select_value(url)==nil then
        --不执行任何操作
    end
    if select_value(url,kong.ctx.url)~=nil then
        if be_cached(requestmap) then
            requestmap = be_cached(requestmap)
        else
            requestmap = kong.db.respond_map:select({url = kong.request.get_json})
        end
        --查询客户端请求对应的api
        apiurl = select_value(api,kong.ctx.api)
        --发起客户端请求的所有子请求
        for k,v in pairs(apiurl) do
           body = send_payload(api.method,v)
            --解析body为table类型
            tablebody = get_json(body)
            --收集所有自请求的body
            table.insert(bodyarray,1,tablebody)
        end
        --合并自请求body的table表为一个
        for k,v in print(bodyarray) do
            overlaidbody = overlay_body(bodyarray,v)
        end
        --组装body
        json_responsebody = assemble_body(kong.ctx.body,overlaidbody)
        --发起响应
        send_response(headers,json_responsebody)

    end
end


--[[
请求和返回处理相关函数
]]

--发送请求
--@parameter method：请求方法POST/GET/...
--@parameter api:发起自请求的地址
--@return 返回请求响应的body(json)
local function send_payload(method,api)
    --local getRequestUrl=parse_url(url)

    local host = kong.request.get_host()
    local port = kong.request.get_port()

    local httpc = http.new()
    httpc:set_timeout(60000)

    ok, err = httpc:connect(host, port)
    if not ok then
        return nil, "failed to connect to " .. host .. ":" .. tostring(port) .. ": " .. err
    end

    if kong.request.get_scheme == "https" then
        local _, err = httpc:ssl_handshake(true, host, false)
        if err then
            return nil, "failed to do SSL handshake with " ..
                    host .. ":" .. tostring(port) .. ": " .. err
        end
    end
    --发起http子请求
    local res, err = httpc:request({
        method = method,
        path = api.path,
        query = kong.request.get_raw_queryy(),
        headers = {
            ["Host"] = api.host,
            ["Content-Type"] = "application/x-www-form-urlencoded",
            --此处需要考虑
            ["Authorization"] = kong.request.ge_header("Authorization"),
        },
        body = kong.request.get_body(),
    })
    if not res then
        return nil, "failed request to " .. host .. ":" .. tostring(port) .. ": " .. err
    end

    local response_body = res:read_body()
    local success = res.status == 200
    local err_msg

    if not success then
        err_msg = "request to " .. host .. ":" .. tostring(port) ..
                " returned status code " .. tostring(res.status) .. " and body " ..
                response_body
    end

    ok, err = httpc:set_keepalive(keepalive)
    if not ok then
        kong.log.err("failed keepalive for ", host, ":", tostring(port), ": ", err)
    end

    return response_body,err_msg

end

--解析json
--@parameter body:响应解析的body
--@return body内容被解析后以table类型返回
local function get_json(body)

    local cjson = require("cjson")
    local json=cjson.new()
    kong.log("解析json开始")
    local table = json.decode(body)

    if table ~= nil and next(table) ~= nil then
        kong.log("取得json"..tostring(table))
    end

    for k, v in pairs(table["RoleList"]) do
        --print(k .. " : " .. v)
        kong.log("\njson存储的值名为："..k.."\n值为："..tostring(v).."\n")
    end
    return table
end

--合并body内容
--@return 返回多个body合并后的body
--@parameter a:table1
--@parameter ...:table2-tablen
local function overlay_body(a,...)
    local table
    local arg = {...}
    for k,v in ipairs(arg) do
        if k==1 then
            table = kong.table.new(a,v)
        end
        kong.table.new(table,v)
    end
    return table
end


--组装body
--@parameter json:json字符串
--@parameter table：源数据表
--@return 元素被替换后的json（最终响应客户端的body）
local function assemble_body(json，table)
    local jp = require('jsonpath')
    local cjson = require("cjson")
    table_json = cjson.decode(json)
    for k,v in pairs(table_json) do
        if jp.query(table,tostring(k))~=nil then
            table_json[k] = jp.query(table,tostring(k))
        end
        if type(v)==table and v~=nil then
            for x,y in pairs(v) do
                if jp.query(table,tostring(k))~=nil then
                    table_json[k] = jp.query(table,tostring(k))
                end
            end
        end
    end
    json_response = cjson.encode(table_json)
    return json_response
end


--返回响应数据
local function send_response(heders,body)
    kong.request.exit(200,body,headers)
end


--将缓存json字符串转换为table并且查询出指定值
--@parameter name:查询参数的键
--@parameter json:缓存中的json字符串
--@return value:查询结果
local function select_value(key,json)
    local cjson = require("cjson")
    local jp = require('jsonpath')
    json_table = cjon.decode(json)
    value = jp.value(json_table,'$..key')
    return value
end

--遍历数据库中的所有映射实体，然后存储到全局变量中
--[[
local function save_allentity()
    local source = {}
    credential, err =kong.db.respond_map:each(1000)
    for respond, err on kong.db.respond_map:each(1000) do
        if err then
            kong.log.err("Error when iterating over keyauth credentials: " .. err)
            return nil
        end
        table.insert(source,1,respond)
    end
    kong.ctx.database = source
end
]]

--验证数据库实体是否被缓存
local function be_cached(key)
    ttl, err, value = cache:probe(key)
    if value~=nil then
        return value
    else
        return false
    end
end


return ResponseHandler